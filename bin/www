#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app')
// var debug = require('debug')('latincard:server')
// var http = require('http')
const { ApolloServer, gql } = require('apollo-server')

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000')
app.set('port', port)

/**
 * Create HTTP server.
 */

//var server = http.createServer(app)
// 1. GraphQL Schema 定義
const typeDefs = gql`
  type Query {
    "A simple type for getting started!"
    hello: String
		me: User
		friends: [User]
		user(name: String!): User
		card: Card
		book: Book
  }

	type User {
		id: Int!
		name: String
		account: String
		password: String
		posts: Post		
	}

	type Card {
		id: Int!
		ch: String!
		chExplain: String
		chPartOfSpeech: String
		en: String!
		enExplain: String
		enPartOfSpeech: String
		la: String!
		laExplain: String
		laPartOfSpeech: String
	}

	type Book {
		UserId: Int!
		CardId: Int!
	}

	type Post {
    "識別碼"
    id: ID!
    "作者"
    author: User
    "標題"
    title: String
    "內容"
    content: String
    "按讚者"
    likeGivers: [User]
  }

	type Mutation {
    "新增貼文"
    addPost(title: String!, content: String!): Post
    "貼文按讚 (收回讚)"
    likePost(postId: ID!): Post
  }
`

const users = [
	{
		id: 1,
		name: 'Fong',
		account: 'user1'
	},
	{
		id: 2,
		name: 'Kevin',
		account: 'user2'
	},
	{
		id: 3,
		name: 'Mary',
		account: 'user3'
	}
]
const posts = [
	{ id: 1, authorId: 1, title: 'Hello World!', content: 'This is my first post.', likeGiverIds: [2] },
	{ id: 2, authorId: 2, title: 'Good Night', content: 'Have a Nice Dream =)', likeGiverIds: [2, 3] },
	{ id: 3, authorId: 1, title: 'I Love U', content: "Here's my second post!", likeGiverIds: [] }
]

const findUserById = id => users.find(user => user.id === id)
const findUserByName = name => users.find(user => user.name === name)
const filterPostsByAuthorId = authorId => posts.filter(post => post.authorId === authorId)
const meId = 1
const findPostById = id => posts.find(post => post.id === id)

// 2. Resolvers 是一個會對照 Schema 中 field 的 function map ，讓你可以計算並回傳資料給 GraphQL Server
const resolvers = {
	Query: {
		// 需注意名稱一定要對到 Schema 中 field 的名稱
		hello: () => 'world',
		me: () => users[0],
		friends: () => users,
		user: (root, args, context) => {
			// 取出參數。因為 name 為 non-null 故一定會有值。
			const { name } = args
			return users.find(user => user.name === name)
		}
	},
	// Mutation Type Resolver
	Mutation: {
		addPost: (root, args, context) => {
			const { title, content } = args
			// 新增 post
			posts.push({
				id: posts.length + 1,
				authorId: meId,
				title,
				content,
				likeGivers: []
			})
			// 回傳新增的那篇 post
			return posts[posts.length - 1]
		},
		likePost: (root, args, context) => {
			const { postId } = args
			const post = findPostById(postId)
			if (!post) throw new Error(`Post ${postId} Not Exists`)

			if (post.likeGiverIds.includes(meId)) {
				// 如果已經按過讚就收回
				const index = post.likeGiverIds.findIndex(v => v === userId)
				post.likeGiverIds.splice(index, 1)
			} else {
				// 否則就加入 likeGiverIds 名單
				post.likeGiverIds.push(meId)
			}
			return post
		}
	},
	User: {
		// 1. User.parent field resolver, 回傳屬於該 user 的 posts
		posts: (parent, args, context) => {
			// parent.id 為 userId
			return filterPostsByAuthorId(parent.id)
		}
	},
	// 2. Post type resolver
	Post: {
		// 2-1. parent 為 post 的資料，透過 post.likeGiverIds 連接到 users
		likeGivers: (parent, args, context) => {
			return parent.likeGiverIds.map(id => findUserById(id))
		},
		// 2-2. parent 為 post 的資料，透過 post.author
		author: (parent, args, context) => {
			return findUserById(parent.authorId)
		}
	}
}

// 3. 初始化 Web Server ，需傳入 typeDefs (Schema) 與 resolvers (Resolver)
const server = new ApolloServer({
	// Schema 部分
	typeDefs,
	// Resolver 部分
	resolvers
})

/**
 * Listen on provided port, on all network interfaces.
 */

// 4. 啟動 Server
server.listen().then(({ url }) => {
	console.log(`? Server ready at ${url}`)
})

// server.listen(port, () => {
// 	console.log(`Example app listening at http://localhost:${port}`)
// })
// server.on('error', onError)
// server.on('listening', onListening)

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort (val) {
	var port = parseInt(val, 10)

	if (isNaN(port)) {
		// named pipe
		return val
	}

	if (port >= 0) {
		// port number
		return port
	}

	return false
}

/**
 * Event listener for HTTP server "error" event.
 */

// function onError (error) {
// 	if (error.syscall !== 'listen') {
// 		throw error
// 	}

// 	var bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port

// 	// handle specific listen errors with friendly messages
// 	switch (error.code) {
// 		case 'EACCES':
// 			console.error(bind + ' requires elevated privileges')
// 			process.exit(1)
// 			break
// 		case 'EADDRINUSE':
// 			console.error(bind + ' is already in use')
// 			process.exit(1)
// 			break
// 		default:
// 			throw error
// 	}
// }

/**
 * Event listener for HTTP server "listening" event.
 */

// function onListening () {
// 	var addr = server.address()
// 	var bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port
// 	debug('Listening on ' + bind)
// }
