#!/usr/bin/env node

/**
 * Module dependencies.
 */

var app = require('../app')
// var debug = require('debug')('latincard:server')
// var http = require('http')
const { ApolloServer, gql } = require('apollo-server')
const bcrypt = require('bcrypt')
const jwt = require('jsonwebtoken')
// 定義 bcrypt 加密所需 saltRounds 次數
const SALT_ROUNDS = 2
// 定義 jwt 所需 secret (可隨便打)
const SECRET = 'just_a_random_secret'

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000')
app.set('port', port)

/**
 * Create HTTP server.
 */

//var server = http.createServer(app)
// 1. GraphQL Schema 定義
const typeDefs = gql`
  type Query {
		me(account: String): User
		users: [User]
		user(account: String): User

		"""
		find cards belong to user id
		"""
		cards(id: Int): User
		books(queryCard: Int): Book

		card(id: Int, la: String,en: String,ch: String): [Card]
  }

	type User {
		id: Int!
		name: String!
		account: String!
		password: String!

		"""
		find cards belong to this user
		"""
		cards: [Card]
	}

	type Card {
		id: Int!
		ch: String
		chExplain: String
		en: String
		enExplain: String
		la: String
		laExplain: String
		partOfSpeech: String
	}

	type Book {
		UserId: Int
		CardId: Int
		card: Card
	}

	type Token {
		token: String!
	}

	input PostCardInput{
		ch: String!
		en: String!
		la: String!
		partOfSpeech: String!
	}

	input EditCardInput{
		id: Int
		ch: String
		en: String
		la: String
		partOfSpeech: String
	}

	type Mutation {
		signUp(name: String, account: String, password: String): User
		login (account: String!, password: String!): Token
    "新增Card"
    postCard(input: PostCardInput!): [Card]
    "編輯Card"
    editCard(input: EditCardInput!): Card
		"刪除Card"
		deleteCard(id: Int!): [Card]
  }
`

const users = [
	{
		id: 1,
		name: 'Fong',
		account: 'user1',
		password: '$2a$10$O2xadlxQWr5U.8PIz6wsgu.I1isDKRnNVXYGE5/EXos6nA1tXcahW'
	},
	{
		id: 2,
		name: 'Kevin',
		account: 'user2',
		password: '12345678'
	},
	{
		id: 3,
		name: 'Mary',
		account: 'user3',
		password: '12345678'
	}
]
const cards = [
	{
		id: 1,
		ch: '愛',
		en: 'love',
		la: 'amo',
		partOfSpeech: '動詞'
	},
	{
		id: 2,
		ch: '女孩',
		en: 'girl',
		la: 'puella',
		partOfSpeech: '名詞'
	},
	{
		id: 3,
		ch: '是',
		en: 'to be',
		la: 'est',
		partOfSpeech: '動詞'
	}
]
const books = [
	{
		id: 1,
		UserId: 1,
		CardId: 1
	},
	{
		id: 2,
		UserId: 2,
		CardId: 2
	},
	{
		id: 3,
		UserId: 3,
		CardId: 3
	},
	{
		id: 4,
		UserId: 1,
		CardId: 3
	}
]

const userController = require('../controllers/userControllers')

// helper functions
const filterCardsByUserId = userId => {
	const matched = books.filter(pair => userId === pair.UserId)
	const result = []
	matched.forEach(item => result.push(...cards.filter(card => card.id === item.CardId)))
	return result
}
const findUserByAccount = account => users.find(user => user.account === account)
const findCardByChName = name => filterCardsByUserId(meId).filter(card => card.ch === name)
const findCardByEnName = name => filterCardsByUserId(meId).filter(card => card.en === name)
const findCardByLaName = name => filterCardsByUserId(meId).filter(card => card.la === name)
const findUserByUserId = userId => users.find(user => user.id === Number(userId))
const findIdByCardId = id => {
	const card = cards.filter(card => card.id === id)
	return card[0].id
}
const hash = text => bcrypt.hash(text, SALT_ROUNDS)
const createToken = ({ id, account, name }) =>
	jwt.sign({ id, account, name }, SECRET, {
		// 在 token 建造時加上 expiredIn: '1d' 的參數表示 token 在一天後過期
		expiresIn: '1d'
	})

// 2. Resolvers 是一個會對照 Schema 中 field 的 function map ，讓你可以計算並回傳資料給 GraphQL Server
const resolvers = {
	Query: {
		// 需注意名稱一定要對到 Schema 中 field 的名稱
		me: (root, account, { me }) => {
			if (!me) throw new Error('Plz Log In First')
			return userController.findUser(me.account)
		},
		users: () => users,
		user: (root, account, context) => {
			if (account) {
				return findUserByAccount(account)
			}
		},
		// find cards belong to specific user by user id
		cards: (root, id, context) => {
			const userId = id.id
			return findUserByUserId(userId)
		},
		card: (root, { id, ch, en, la }, context) => {
			if (ch) {
				return findCardByChName(ch)
			} else if (en) {
				return findCardByEnName(en)
			} else if (la) {
				return findCardByLaName(la)
			} else if (id) {
				return filterCardsByUserId(id)
			}
			return null
		},
		// This is parent for Book.card
		books: (root, { queryCard }, context) => {
			const userId = queryCard
			const matched = books.filter(pair => queryCard === pair.CardId)
			return matched[0]
		}
	},
	User: {
		// take cards to specific user
		cards: (parent, args, context) => {
			return filterCardsByUserId(parent.id)
		}
	},
	Book: {
		// take cards to specific user
		card: (parent, args, context) => {
			const matched = cards.filter(pair => parent.CardId === pair.id)
			return matched[0]
		}
	},
	// Mutation Type Resolver
	Mutation: {
		// 需注意！args 打開後第一層為 input ，再進去一層才是 title, content
		signUp: async (parent, { name, account, password }, context) => {
			// 1. 檢查不能有重複註冊 account
			const isUserAccountDuplicate = users.some(user => user.account === account)
			if (isUserAccountDuplicate) throw new Error('User Account Duplicate')

			const hashedPassword = await hash(password, SALT_ROUNDS)
			users.push({
				id: users.length + 1,
				name,
				account,
				password: hashedPassword
			})
			return users[users.length - 1]
		},
		login: async (root, { account, password }, context) => {
			// 1. 透過 account 找到相對應的 user
			const user = users.find(user => user.account === account)
			if (!user) throw new Error('Account Not Exists')
			// 2. 將傳進來的 password 與資料庫存的 user.password 做比對
			const passwordIsValid = (await bcrypt.compare(password, user.password)) || password === user.password
			if (!passwordIsValid) throw new Error('Wrong Password')
			// 3. 成功則回傳 token
			return { token: await createToken(user) }
		},
		postCard: (parent, { input }, context) => {
			const { ch, en, la, partOfSpeech } = input
			cards.push({
				id: cards.length + 1,
				ch: ch,
				en: en,
				la: la,
				partOfSpeech: partOfSpeech
			})
			console.log(cards)
			return cards
		},
		editCard: (parent, { input }, content) => {
			const { id, ch, en, la, partOfSpeech } = input
			const targetIndex = cards.findIndex(card => card.id === id)
			cards[targetIndex] = {
				id,
				ch,
				en,
				la,
				partOfSpeech
			}
			return cards[targetIndex]
		},
		deleteCard: (parent, { id }, content) => {
			const targetId = findIdByCardId(id)
			return cards.filter(card => card.id !== targetId)
		}
	}
}

// 3. 初始化 Web Server ，需傳入 typeDefs (Schema) 與 resolvers (Resolver)
const server = new ApolloServer({
	// Schema 部分
	typeDefs,
	// Resolver 部分
	resolvers,
	context: async ({ req }) => {
		// 1. 將 token 從 request header 的 x-token 取出
		const token = req.headers['x-token']
		if (token) {
			try {
				// 2. 檢查 token + 取得解析出的資料
				const me = await jwt.verify(token, SECRET)
				// 3. 放進 context
				return { me }
			} catch (e) {
				throw new Error('Your session expired. Sign in again.')
			}
		}
		// 如果沒有 token 就回傳空的 context 出去
		return {}
	}
})

/**
 * Listen on provided port, on all network interfaces.
 */

// 4. 啟動 Server
server.listen().then(({ url }) => {
	console.log(`? Server ready at ${url}`)
})

// server.listen(port, () => {
// 	console.log(`Example app listening at http://localhost:${port}`)
// })
// server.on('error', onError)
// server.on('listening', onListening)

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort (val) {
	var port = parseInt(val, 10)

	if (isNaN(port)) {
		// named pipe
		return val
	}

	if (port >= 0) {
		// port number
		return port
	}

	return false
}

/**
 * Event listener for HTTP server "error" event.
 */

// function onError (error) {
// 	if (error.syscall !== 'listen') {
// 		throw error
// 	}

// 	var bind = typeof port === 'string' ? 'Pipe ' + port : 'Port ' + port

// 	// handle specific listen errors with friendly messages
// 	switch (error.code) {
// 		case 'EACCES':
// 			console.error(bind + ' requires elevated privileges')
// 			process.exit(1)
// 			break
// 		case 'EADDRINUSE':
// 			console.error(bind + ' is already in use')
// 			process.exit(1)
// 			break
// 		default:
// 			throw error
// 	}
// }

/**
 * Event listener for HTTP server "listening" event.
 */

// function onListening () {
// 	var addr = server.address()
// 	var bind = typeof addr === 'string' ? 'pipe ' + addr : 'port ' + addr.port
// 	debug('Listening on ' + bind)
// }
